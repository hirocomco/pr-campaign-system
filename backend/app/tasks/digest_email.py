"""Daily digest email generation and sending tasks."""

import asyncio
import logging
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import smtplib
from jinja2 import Environment, BaseLoader
from sqlalchemy import select, func, desc
from sqlalchemy.ext.asyncio import AsyncSession

from .celery_app import celery_app
from ..core.database import get_session
from ..core.config import settings
from ..models.trend import Trend
from ..models.campaign import Campaign

logger = logging.getLogger(__name__)

# Email templates
EMAIL_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Daily PR Trends Digest - {{ date }}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 8px; margin-bottom: 30px; }
        .header h1 { margin: 0; font-size: 28px; }
        .stats { display: flex; justify-content: space-between; margin: 20px 0; }
        .stat { text-align: center; }
        .stat-number { font-size: 24px; font-weight: bold; color: #667eea; }
        .trend-card { border: 1px solid #e1e5e9; border-radius: 8px; padding: 20px; margin: 15px 0; }
        .trend-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; color: #2c3e50; }
        .trend-score { float: right; background: #28a745; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
        .trend-meta { color: #6c757d; font-size: 14px; margin: 5px 0; }
        .campaign-preview { background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 10px 0; }
        .footer { text-align: center; color: #6c757d; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e1e5e9; }
        .cta-button { display: inline-block; background: #667eea; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin: 10px 0; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Daily PR Trends Digest</h1>
            <p>{{ date }} - Your daily dose of trending opportunities</p>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-number">{{ stats.new_trends }}</div>
                <div>New Trends</div>
            </div>
            <div class="stat">
                <div class="stat-number">{{ stats.total_campaigns }}</div>
                <div>Campaign Ideas</div>
            </div>
            <div class="stat">
                <div class="stat-number">{{ stats.high_potential }}</div>
                <div>High Potential</div>
            </div>
        </div>
        
        <h2>ðŸ”¥ Top Trending Opportunities</h2>
        {% for trend in top_trends %}
        <div class="trend-card">
            <div class="trend-title">
                {{ trend.title }}
                <span class="trend-score">{{ "%.0f"|format(trend.score) }}</span>
            </div>
            <div class="trend-meta">
                ðŸ“Š {{ trend.platforms|join(', ') }} | 
                ðŸŽ¯ {{ "%.0f"|format(trend.pr_potential_score or 0) }}% PR Potential |
                âš¡ {{ "%.0f"|format(trend.viral_potential_score or 0) }}% Viral Potential
            </div>
            <p>{{ trend.description }}</p>
            
            {% if trend.top_campaign %}
            <div class="campaign-preview">
                <strong>ðŸ’¡ Campaign Idea:</strong> {{ trend.top_campaign.title }}
                <br><small>{{ trend.top_campaign.description[:150] }}...</small>
            </div>
            {% endif %}
        </div>
        {% endfor %}
        
        {% if rising_trends %}
        <h2>ðŸ“ˆ Rising Trends to Watch</h2>
        <ul>
        {% for trend in rising_trends %}
            <li><strong>{{ trend.title }}</strong> - {{ "%.0f"|format(trend.score) }} score, growing {{ "%.1f"|format(trend.growth_rate) }}%</li>
        {% endfor %}
        </ul>
        {% endif %}
        
        <div style="text-align: center; margin: 30px 0;">
            <a href="{{ dashboard_url }}" class="cta-button">View Full Dashboard</a>
        </div>
        
        <div class="footer">
            <p>This digest was automatically generated by your PR Campaign Ideation System.</p>
            <p><a href="{{ unsubscribe_url }}">Unsubscribe</a> | <a href="{{ settings_url }}">Email Preferences</a></p>
        </div>
    </div>
</body>
</html>
"""

@celery_app.task(bind=True, max_retries=3)
def send_daily_digest(self, recipient_emails: List[str] = None):
    """
    Generate and send daily digest emails to subscribers.
    
    Args:
        recipient_emails: Optional list of specific recipients
    """
    try:
        return asyncio.run(_generate_and_send_digest(recipient_emails))
    except Exception as exc:
        logger.error(f"Daily digest sending failed: {exc}")
        raise self.retry(exc=exc, countdown=300)

async def _generate_and_send_digest(recipient_emails: List[str] = None) -> Dict[str, Any]:
    """
    Generate and send the daily digest email.
    
    Args:
        recipient_emails: Optional list of specific recipients
        
    Returns:
        Send results summary
    """
    try:
        async with get_session() as session:
            # Gather digest data
            digest_data = await _gather_digest_data(session)
            
            if not digest_data["top_trends"]:
                logger.info("No significant trends found for digest")
                return {"status": "no_content", "sent": 0}
            
            # Generate email content
            email_html = await _generate_email_content(digest_data)
            
            # Get recipient list
            recipients = recipient_emails or await _get_digest_recipients(session)
            
            if not recipients:
                logger.info("No recipients found for digest")
                return {"status": "no_recipients", "sent": 0}
            
            # Send emails
            sent_count = await _send_digest_emails(email_html, recipients, digest_data)
            
            # Log digest generation
            await _log_digest_generation(session, digest_data, sent_count)
            
            return {
                "status": "success",
                "sent": sent_count,
                "recipients": len(recipients),
                "trends_included": len(digest_data["top_trends"]),
                "timestamp": datetime.utcnow().isoformat()
            }
            
    except Exception as e:
        logger.error(f"Error generating daily digest: {e}")
        raise

async def _gather_digest_data(session: AsyncSession) -> Dict[str, Any]:
    """Gather all data needed for the digest email."""
    yesterday = datetime.utcnow() - timedelta(days=1)
    
    # Get top trends from last 24 hours
    trends_query = (
        select(Trend)
        .where(Trend.created_at >= yesterday)
        .where(Trend.score >= 60.0)  # Only high-quality trends
        .order_by(desc(Trend.score))
        .limit(5)
    )
    
    trends_result = await session.execute(trends_query)
    top_trends = trends_result.scalars().all()
    
    # Get rising trends (trends with positive momentum)
    rising_query = (
        select(Trend)
        .where(Trend.created_at >= yesterday - timedelta(days=2))  # Last 3 days
        .where(Trend.viral_potential_score >= 70.0)
        .order_by(desc(Trend.viral_potential_score))
        .limit(3)
    )
    
    rising_result = await session.execute(rising_query)
    rising_trends = rising_result.scalars().all()
    
    # Get campaign counts
    campaigns_query = (
        select(func.count(Campaign.id))
        .where(Campaign.created_at >= yesterday)
    )
    
    campaigns_result = await session.execute(campaigns_query)
    new_campaigns_count = campaigns_result.scalar() or 0
    
    # Get stats
    new_trends_query = (
        select(func.count(Trend.id))
        .where(Trend.created_at >= yesterday)
    )
    
    new_trends_result = await session.execute(new_trends_query)
    new_trends_count = new_trends_result.scalar() or 0
    
    high_potential_query = (
        select(func.count(Trend.id))
        .where(Trend.created_at >= yesterday)
        .where(Trend.pr_potential_score >= 80.0)
    )
    
    high_potential_result = await session.execute(high_potential_query)
    high_potential_count = high_potential_result.scalar() or 0
    
    # Enrich trends with top campaign for each
    for trend in top_trends:
        campaign_query = (
            select(Campaign)
            .where(Campaign.trend_id == trend.id)
            .order_by(desc(Campaign.overall_score))
            .limit(1)
        )
        
        campaign_result = await session.execute(campaign_query)
        top_campaign = campaign_result.scalar_one_or_none()
        trend.top_campaign = top_campaign
        
        # Calculate growth rate for display
        trend.growth_rate = (trend.viral_potential_score or 0) * 0.1  # Mock calculation
    
    # Calculate growth rates for rising trends
    for trend in rising_trends:
        trend.growth_rate = (trend.viral_potential_score or 0) * 0.15  # Mock calculation
    
    return {
        "top_trends": top_trends,
        "rising_trends": rising_trends,
        "stats": {
            "new_trends": new_trends_count,
            "total_campaigns": new_campaigns_count,
            "high_potential": high_potential_count,
        },
        "date": datetime.utcnow().strftime("%B %d, %Y"),
        "dashboard_url": f"{settings.FRONTEND_URL}/dashboard",
        "unsubscribe_url": f"{settings.FRONTEND_URL}/unsubscribe",
        "settings_url": f"{settings.FRONTEND_URL}/settings",
    }

async def _generate_email_content(digest_data: Dict[str, Any]) -> str:
    """Generate HTML email content from digest data."""
    try:
        env = Environment(loader=BaseLoader())
        template = env.from_string(EMAIL_TEMPLATE)
        
        html_content = template.render(**digest_data)
        return html_content
        
    except Exception as e:
        logger.error(f"Error generating email content: {e}")
        raise

async def _get_digest_recipients(session: AsyncSession) -> List[str]:
    """Get list of email addresses for digest recipients."""
    # In a real implementation, this would query a users/subscribers table
    # For now, return configured email addresses
    default_recipients = getattr(settings, 'DIGEST_RECIPIENTS', [])
    
    if isinstance(default_recipients, str):
        return [default_recipients]
    elif isinstance(default_recipients, list):
        return default_recipients
    else:
        return []

async def _send_digest_emails(
    html_content: str, recipients: List[str], digest_data: Dict[str, Any]
) -> int:
    """Send digest emails to all recipients."""
    sent_count = 0
    
    try:
        # Configure SMTP
        smtp_server = settings.SMTP_SERVER
        smtp_port = settings.SMTP_PORT
        smtp_username = settings.SMTP_USERNAME
        smtp_password = settings.SMTP_PASSWORD
        from_email = settings.FROM_EMAIL
        
        if not all([smtp_server, smtp_username, smtp_password, from_email]):
            logger.warning("SMTP not configured, skipping email sending")
            return 0
        
        # Create SMTP connection
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(smtp_username, smtp_password)
        
        # Send to each recipient
        for recipient in recipients:
            try:
                # Create message
                msg = MIMEMultipart('alternative')
                msg['Subject'] = f"Daily PR Trends Digest - {digest_data['date']}"
                msg['From'] = from_email
                msg['To'] = recipient
                
                # Add HTML content
                html_part = MIMEText(html_content, 'html')
                msg.attach(html_part)
                
                # Send email
                text = msg.as_string()
                server.sendmail(from_email, recipient, text)
                sent_count += 1
                
                logger.info(f"Digest sent to {recipient}")
                
            except Exception as e:
                logger.error(f"Failed to send digest to {recipient}: {e}")
        
        server.quit()
        
    except Exception as e:
        logger.error(f"SMTP error: {e}")
    
    return sent_count

async def _log_digest_generation(
    session: AsyncSession, digest_data: Dict[str, Any], sent_count: int
):
    """Log digest generation for analytics."""
    try:
        # In a real implementation, you might store digest logs in a table
        logger.info(
            f"Daily digest generated: {sent_count} emails sent, "
            f"{len(digest_data['top_trends'])} trends included"
        )
        
        # Could store in a digest_logs table for analytics
        # digest_log = DigestLog(
        #     sent_count=sent_count,
        #     trends_count=len(digest_data['top_trends']),
        #     recipient_count=sent_count,
        #     generated_at=datetime.utcnow()
        # )
        # session.add(digest_log)
        # await session.commit()
        
    except Exception as e:
        logger.error(f"Error logging digest generation: {e}")

@celery_app.task
def send_weekly_summary():
    """Send a weekly summary email with trend analytics."""
    try:
        return asyncio.run(_send_weekly_summary())
    except Exception as exc:
        logger.error(f"Weekly summary sending failed: {exc}")
        raise

async def _send_weekly_summary() -> Dict[str, Any]:
    """Generate and send weekly summary email."""
    try:
        async with get_session() as session:
            # Get last week's data
            week_ago = datetime.utcnow() - timedelta(days=7)
            
            # Top performing trends
            trends_query = (
                select(Trend)
                .where(Trend.created_at >= week_ago)
                .order_by(desc(Trend.score))
                .limit(10)
            )
            
            trends_result = await session.execute(trends_query)
            top_trends = trends_result.scalars().all()
            
            # Weekly stats
            total_trends_query = (
                select(func.count(Trend.id))
                .where(Trend.created_at >= week_ago)
            )
            
            total_trends_result = await session.execute(total_trends_query)
            total_trends = total_trends_result.scalar() or 0
            
            # Generate weekly content (simplified)
            weekly_data = {
                "top_trends": top_trends[:5],
                "stats": {
                    "total_trends": total_trends,
                    "avg_score": sum(t.score for t in top_trends) / len(top_trends) if top_trends else 0,
                },
                "date": f"Week of {week_ago.strftime('%B %d, %Y')}",
                "dashboard_url": f"{settings.FRONTEND_URL}/dashboard",
            }
            
            # Use simplified template for weekly summary
            html_content = await _generate_weekly_content(weekly_data)
            
            # Get recipients
            recipients = await _get_digest_recipients(session)
            
            # Send weekly emails
            sent_count = await _send_weekly_emails(html_content, weekly_data, recipients)
            
            return {
                "status": "success",
                "sent": sent_count,
                "trends_analyzed": total_trends,
                "timestamp": datetime.utcnow().isoformat()
            }
            
    except Exception as e:
        logger.error(f"Error sending weekly summary: {e}")
        raise

async def _generate_weekly_content(weekly_data: Dict[str, Any]) -> str:
    """Generate weekly summary email content."""
    # Simplified weekly template
    weekly_template = """
    <html>
    <body style="font-family: Arial, sans-serif;">
        <h1>Weekly PR Trends Summary</h1>
        <h2>{{ date }}</h2>
        
        <p>This week we analyzed {{ stats.total_trends }} trends with an average score of {{ "%.1f"|format(stats.avg_score) }}.</p>
        
        <h3>Top Performing Trends:</h3>
        <ul>
        {% for trend in top_trends %}
            <li><strong>{{ trend.title }}</strong> - Score: {{ "%.0f"|format(trend.score) }}</li>
        {% endfor %}
        </ul>
        
        <p><a href="{{ dashboard_url }}">View Full Analytics Dashboard</a></p>
    </body>
    </html>
    """
    
    env = Environment(loader=BaseLoader())
    template = env.from_string(weekly_template)
    return template.render(**weekly_data)

async def _send_weekly_emails(
    html_content: str, weekly_data: Dict[str, Any], recipients: List[str]
) -> int:
    """Send weekly summary emails."""
    # Similar to daily digest sending but with weekly subject
    sent_count = 0
    
    try:
        # Configure SMTP (same as daily digest)
        smtp_server = settings.SMTP_SERVER
        smtp_port = settings.SMTP_PORT
        smtp_username = settings.SMTP_USERNAME
        smtp_password = settings.SMTP_PASSWORD
        from_email = settings.FROM_EMAIL
        
        if not all([smtp_server, smtp_username, smtp_password, from_email]):
            logger.warning("SMTP not configured, skipping weekly email sending")
            return 0
        
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(smtp_username, smtp_password)
        
        for recipient in recipients:
            try:
                msg = MIMEMultipart('alternative')
                msg['Subject'] = f"Weekly PR Trends Summary - {weekly_data['date']}"
                msg['From'] = from_email
                msg['To'] = recipient
                
                html_part = MIMEText(html_content, 'html')
                msg.attach(html_part)
                
                text = msg.as_string()
                server.sendmail(from_email, recipient, text)
                sent_count += 1
                
            except Exception as e:
                logger.error(f"Failed to send weekly summary to {recipient}: {e}")
        
        server.quit()
        
    except Exception as e:
        logger.error(f"SMTP error in weekly summary: {e}")
    
    return sent_count 